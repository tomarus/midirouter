#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
#include "xuartlite.h"
#include "xuartlite_l.h"
#include "xil_io.h"
#include "led_shift_594_driver.h"

// define to run tests
//#define TESTING
#ifdef TESTING
void RunTests(void);
#endif

#define NUM_PORTS 15

#define OUTPUT_BUFFER_LENGTH 16 // Each output port has NUM_PORTS * OUTPUT_BUFFER_LENGTH storage

#define ACTIVITY(IN, OUT) \
    	LED_SHIFT_594_DRIVER_mWriteReg(XPAR_LED_SHIFT_594_DRIVER_0_S00_AXI_BASEADDR, LED_SHIFT_594_DRIVER_S00_AXI_SLV_REG0_OFFSET, IN&0xffff); \
    	LED_SHIFT_594_DRIVER_mWriteReg(XPAR_LED_SHIFT_594_DRIVER_0_S00_AXI_BASEADDR, LED_SHIFT_594_DRIVER_S00_AXI_SLV_REG1_OFFSET, OUT&0xffff);

const u32 XUartLite_PortAddrs[] = {
		XPAR_AXI_UARTLITE_1_BASEADDR,
		XPAR_AXI_UARTLITE_2_BASEADDR,
		XPAR_AXI_UARTLITE_3_BASEADDR,
		XPAR_AXI_UARTLITE_4_BASEADDR,
		XPAR_AXI_UARTLITE_5_BASEADDR,
		XPAR_AXI_UARTLITE_6_BASEADDR,
//		XPAR_AXI_UARTLITE_7_BASEADDR, // This port has a hardware defect :(
		XPAR_AXI_UARTLITE_8_BASEADDR,
		XPAR_AXI_UARTLITE_9_BASEADDR,
		XPAR_AXI_UARTLITE_10_BASEADDR,
		XPAR_AXI_UARTLITE_11_BASEADDR,
		XPAR_AXI_UARTLITE_12_BASEADDR,
		XPAR_AXI_UARTLITE_13_BASEADDR,
		XPAR_AXI_UARTLITE_14_BASEADDR,
		XPAR_AXI_UARTLITE_15_BASEADDR,
		XPAR_AXI_UARTLITE_16_BASEADDR
};

//
// FIFO Methods
//

typedef struct {
	u8 buf[OUTPUT_BUFFER_LENGTH];
	u8 rpos;
	u8 wpos;
} fifo;

void fifo_add_byte(fifo *f, u8 b) {
	f->wpos++;
	if (f->wpos>OUTPUT_BUFFER_LENGTH-1) {
		f->wpos=0;
	}
	f->buf[f->wpos] = b;
}

u8 fifo_read_byte(fifo *f) {
	f->rpos++;
	if (f->rpos>OUTPUT_BUFFER_LENGTH-1) {
		f->rpos=0;
	}
	return f->buf[f->rpos];
}

u8 fifo_is_empty(fifo *f) {
	return f->rpos == f->wpos;
}

u8 fifo_is_full(fifo *f) {
	return ((f->rpos-1)&(OUTPUT_BUFFER_LENGTH-1)) == f->wpos;
}

//
// Output Merging
//

enum {
	STATE_LOOP,
	STATE_WAITXMIT
};

typedef struct {
	fifo fifo[NUM_PORTS];
	u8 lastcmd[NUM_PORTS];
	u8 active_input_port;
	u8 expect_byte;
	u8 expect_bytes;
	u8 nextbyte;
	u8 midibyte;
	u8 state;
} outport;

outport outports[NUM_PORTS];

void QueueOutputByte(int fromport, int dstport, u8 byte) {
	if (fifo_is_full(outports[dstport].fifo)) {
		xil_printf("FIFO overrun from port %d to port %d\r\n", fromport, dstport);
	}
	fifo_add_byte(outports[dstport].fifo, byte);
}

void PostSendByte(outport *p) {
	switch(p->midibyte&0xf) {
	case 0x8: // note off
	case 0x9: // note on
	case 0xa: // key pressure
	case 0xb: // control change
	case 0xe: // pitch bend
		p->expect_bytes = 2;
		break;
	case 0xc: // program change
	case 0xd: // channel pressure
		p->expect_bytes = 1;
		break;
	case 0xf:
		switch (p->midibyte) {
		case 0xf0: // sysex
			p->expect_byte = 0xf7;
			p->expect_bytes = 0;
			break;
		case 0xf1: // time code frame
		case 0xf3: // song select
			p->expect_bytes = 1;
			break;
		case 0xf2: // song position
			p->expect_bytes = 2;
			break;
		default:
			p->expect_bytes = 0;
			break;
		}
		break;
	default:
		if (p->expect_bytes > 0) {
			p->expect_bytes = p->expect_bytes - 1;
		} else {
			p->expect_bytes = 0;
		}
		break;
	}

	if (p->expect_byte > 0 && p->midibyte == p->expect_byte) {
		p->expect_bytes = 0;
	}
}

u8 TrySendByte(outport *p, int portnum) {
	if (XUartLite_IsReceiveEmpty(XUartLite_PortAddrs[portnum])) {
		XUartLite_SendByte(XUartLite_PortAddrs[portnum], p->midibyte);
		PostSendByte(p);
		return 1;
	}
	return 0;
}

u16 ProcessOutputPort(int port) {
	u8 activity = 0;
	outport *p = &outports[port];
	fifo *fifo;

	switch (p->state) {
	case STATE_LOOP:
		fifo = &p->fifo[p->active_input_port];

		if (p->nextbyte != 0) {
			xil_printf("read nextbyte 0x%x\r\n", p->nextbyte);
			// we have to xmit the previous command
			// as we are in a midi continuous message here.
			p->midibyte = p->nextbyte;
			p->nextbyte = 0;
		} else 	if (!fifo_is_empty(fifo) ) {
			p->midibyte = fifo_read_byte(fifo);
		} else {
			// check next port on next run
			p->active_input_port++;
			if (p->active_input_port > NUM_PORTS-1) {
				p->active_input_port = 0;
			}
			break;
		}

		if (!(p->midibyte&0x80) && p->expect_byte == 0 && p->expect_bytes == 0) {
			p->nextbyte = p->midibyte;
			p->midibyte = p->lastcmd[p->active_input_port];
			xil_printf("received cc msg last command 0x%x\r\n", p->midibyte);
		} else {
			p->lastcmd[p->active_input_port] = p->midibyte;
		}

		if (TrySendByte(p, port) == 1) {
			activity++;
		} else {
			p->state = STATE_WAITXMIT;
		}
		break;


	case STATE_WAITXMIT:
		if (TrySendByte(p, port) == 1) {
			activity++;
			p->state = STATE_LOOP;
		}
		break;

	default:
		p->state = STATE_LOOP;
		break;
	}

	return activity;
}

//
// Input Processing
//

u16 ReadInputPort(int port) {
	if (XUartLite_IsReceiveEmpty(XUartLite_PortAddrs[port])) {
		return 0;
	}

	u8 b = XUartLite_RecvByte(XUartLite_PortAddrs[port]);
	switch (b) {
	case 254:
	case 255:
		return 0;
	default:
		// send to all output ports for now
		for (int i=0;i<NUM_PORTS;i++) {
			if (port!=i) { // forward to all ports but ourself
				QueueOutputByte(port, i, b);
			}
		}
		return 1;
	}
}


//
// Main loop
//

void sleep(int dur)
{
	for (volatile int d = 0; d < dur; d++) { }
}

int main()
{
    init_platform();

    print("MIDI Merger Initialized\n\r");
    print("http://github.com/tomarus/midirouter\r\n");

    // Reset all output ports
    for (int i=0; i<NUM_PORTS; i++) {
    	bzero(&outports[i], sizeof(outport));
    }

#ifdef TESTING
    RunTests();
#else
    // Little boot sequence to indicate we are running.
	for (int i = 0; i<16; i++) {
    	int x = 1<<i;
    	ACTIVITY(x, x);
    	sleep(500000);
    }
    ACTIVITY(0, 0);

    // loop
    while (1) {
    	u16 inact = 0, outact = 0;
    	for (u16 i=0; i<NUM_PORTS; i++) {
    		if (ReadInputPort(i)) {
    			inact |= 1<<i;
    		}
    		if (ProcessOutputPort(i)) {
    			outact |= 1<<i;
    		}
    	}
   		ACTIVITY(inact, outact);
    }
#endif
    // unreachable
    cleanup_platform();
    return 0;
}

#ifdef TESTING
void RunTests(void) {
    xil_printf("sizeof outport = %d\r\n", sizeof(outport));

    fifo *f = outports[0].fifo;
    if (!fifo_is_empty(f)) {
    	print("fifo should be empty\r\n");

    }
    fifo_add_byte(f, 0xaa);
    fifo_add_byte(f, 0x55);
    fifo_add_byte(f, 0xcc);
    u8 b = fifo_read_byte(f);
    if (b != 0xaa) {
    	print("expected to read byte 0xaa");
    }
    b = fifo_read_byte(f);
    b = fifo_read_byte(f);
    if (b != 0xcc) {
    	print("expected to read byte 0xcc");
    }

    print("tests done\r\n");
}
#endif
